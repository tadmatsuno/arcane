# Generated by codex
import sys
import os
import unittest
import doctest
import importlib
import shutil
from pathlib import Path

#!/usr/bin/env python3

EXCLUDE_DIRS = {
    ".git", ".hg", ".svn", ".idea", ".vscode", "__pycache__", "build", "dist",
    ".tox", ".venv", "venv", "env", "node_modules", ".mypy_cache", ".pytest_cache",
    "coverage", "htmlcov", ".ruff_cache"
}
EXCLUDE_TEST_DIR_NAMES = {"test", "tests"}
EXCLUDE_MODULE_PREFIXES = {"arcane.continuum", "arcane.ew"} # These tests will fail due to Qt backend issues

def find_project_root(start: Path) -> Path:
    markers = {"pyproject.toml", "setup.cfg", "setup.py", "requirements.txt", ".git"}
    cur = start.resolve()
    for p in [cur] + list(cur.parents):
        if any((p / m).exists() for m in markers):
            return p
    return cur

def is_pkg_dir(p: Path) -> bool:
    return p.is_dir() and (p / "__init__.py").exists()

def iter_module_names(root: Path):
    # All importable modules under root, excluding test dirs and excluded dirs
    for path in root.rglob("*.py"):
        if any(part in EXCLUDE_DIRS for part in path.parts):
            continue
        # Exclude test dirs/files
        if any(part in EXCLUDE_TEST_DIR_NAMES for part in path.parts):
            continue
        rel = path.relative_to(root)
        if rel == Path("setup.py"):
            continue
        if rel.name == "__init__.py":
            # package module name (skip top-level __init__ if rel has only one part)
            if len(rel.parts) == 1:
                continue
            mod = ".".join(rel.with_suffix("").parts[:-1])
        else:
            mod = ".".join(rel.with_suffix("").parts)
        if any(mod == prefix or mod.startswith(prefix + ".") for prefix in EXCLUDE_MODULE_PREFIXES):
            continue
        # Ensure module is importable (belongs to a package or top-level module)
        if len(rel.parts) > 1:
            # All parent dirs must be packages
            parents = list(Path(rel).parents)[:-1]  # exclude root
            if not all(is_pkg_dir(root / p) for p in parents):
                continue
        yield mod

def build_smoke_tests(module_names):
    class ImportSmokeTests(unittest.TestCase):
        maxDiff = None
        pass
    for mod in sorted(set(module_names)):
        def _mk_test(m):
            def _test(self):
                importlib.invalidate_caches()
                imported = importlib.import_module(m)
                self.assertIsNotNone(imported, f"Failed to import {m}")
            return _test
        setattr(ImportSmokeTests, f"test_import_{mod.replace('.', '__')}", _mk_test(mod))
    return unittest.defaultTestLoader.loadTestsFromTestCase(ImportSmokeTests)

def build_doctest_suite(module_names):
    suite = unittest.TestSuite()
    for mod in sorted(set(module_names)):
        try:
            importlib.invalidate_caches()
            m = importlib.import_module(mod)
        except Exception:
            # Skip modules that cannot be imported by smoke tests; they will be caught there
            continue
        try:
            ds = doctest.DocTestSuite(m, optionflags=doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE)
        except ValueError:
            # No doctests
            continue
        suite.addTests(ds)
    return suite

def discover_existing_tests(start_dir: Path, top_level_dir: Path):
    loader = unittest.defaultTestLoader
    # When the test directory is not a package, ``loader.discover`` raises because
    # the start directory is not importable. Fall back to letting unittest treat
    # the start directory as the top level in that case.
    if (start_dir / "__init__.py").exists():
        return loader.discover(
            start_dir=str(start_dir),
            pattern="test*.py",
            top_level_dir=str(top_level_dir),
        )
    return loader.discover(start_dir=str(start_dir), pattern="test*.py")

def clear_output_dir(output_dir: Path):
    output_dir.mkdir(parents=True, exist_ok=True)
    for entry in list(output_dir.iterdir()):
        try:
            if entry.is_dir():
                shutil.rmtree(entry)
            else:
                entry.unlink()
        except Exception:
            # Ignore cleanup errors so test execution can proceed.
            continue

def main():
    this_file = Path(__file__).resolve()
    tests_dir = this_file.parent
    project_root = find_project_root(tests_dir)
    if str(project_root) not in sys.path:
        sys.path.insert(0, str(project_root))

    clear_output_dir(tests_dir / "output")
    clear_output_dir(project_root / "output")

    # 1) Existing tests in and under the tests_dir
    existing_suite = discover_existing_tests(tests_dir, project_root)

    # 2) Auto-generated tests (import smoke + doctests) for project modules
    module_names = list(iter_module_names(project_root))
    smoke_suite = build_smoke_tests(module_names)
    doctest_suite = build_doctest_suite(module_names)

    # Combine suites
    all_tests = unittest.TestSuite()
    all_tests.addTests(existing_suite)
    all_tests.addTests(smoke_suite)
    all_tests.addTests(doctest_suite)

    verbosity = int(os.environ.get("TEST_VERBOSITY", "2"))
    failfast = os.environ.get("TEST_FAILFAST", "0") == "1"

    runner = unittest.TextTestRunner(verbosity=verbosity, failfast=failfast)
    result = runner.run(all_tests)
    sys.exit(0 if result.wasSuccessful() else 1)

if __name__ == "__main__":
    main()
